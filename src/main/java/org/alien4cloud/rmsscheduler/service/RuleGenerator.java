package org.alien4cloud.rmsscheduler.service;

import alien4cloud.tosca.serializer.VelocityUtil;
import com.google.common.collect.Sets;
import lombok.extern.slf4j.Slf4j;
import org.alien4cloud.alm.deployment.configuration.flow.FlowExecutionLog;
import org.alien4cloud.rmsscheduler.RMSPluginConfiguration;
import org.alien4cloud.rmsscheduler.model.Rule;
import org.alien4cloud.rmsscheduler.utils.KieUtils;
import org.apache.commons.lang.exception.ExceptionUtils;
import org.kie.api.builder.Message;
import org.kie.api.builder.Results;
import org.kie.api.io.ResourceType;
import org.kie.internal.utils.KieHelper;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import java.io.IOException;
import java.io.StringWriter;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Rules are templated and generated using velocity.
 */
@Service
@Slf4j
public class RuleGenerator {

    @Resource
    private RMSPluginConfiguration pluginConfiguration;

    private String ruleCompileDrl;
    private String ruleCompileDsl;

    @PostConstruct
    public void init() throws IOException {
        // Generate main.drl from template
        Map<String, Object> velocityCtx = new HashMap<>();
        velocityCtx.put("pluginConfiguration", pluginConfiguration);
        StringWriter writer = new StringWriter();
        VelocityUtil.generate("rules/schedule-workflow-main.drl.vm", writer, velocityCtx);
        this.ruleCompileDrl = writer.toString();
        log.info("Will use this main DRL : {}", this.ruleCompileDrl);
        // TODO: should load embeded DSLs

        this.ruleCompileDsl = KieUtils.loadResource("rules/schedule-workflow.dsl");
    }

    private String generateRule(Rule rule) {
        Map<String, Object> velocityCtx = new HashMap<>();
        velocityCtx.put("rule", rule);

        ClassLoader oldctccl = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
        try {
            StringWriter writer = new StringWriter();
            VelocityUtil.generate("rules/schedule-workflow-policy.dslr.vm", writer, velocityCtx);
            return writer.toString();
        } catch (Exception e) {
            log.error("Exception while templating rule " + rule.getId(), e);
            return ExceptionUtils.getFullStackTrace(e);
        } finally {
            Thread.currentThread().setContextClassLoader(oldctccl);
        }
    }

    public KieHelper buildKieHelper(Collection<Rule> rules) {
        KieHelper kieHelper = new KieHelper();
        kieHelper.addContent(ruleCompileDrl, ResourceType.DRL);
        // We need to name the DSL since it's referenced in DSLR
        kieHelper.addContent(ruleCompileDsl, "drools-poc.dsl");

        for (Rule rule : rules) {
            String ruleText = generateRule(rule);
            log.debug("Rule generated by velocity: {}", ruleText);
            kieHelper.addContent(ruleText, ResourceType.DSLR);
        }

        return kieHelper;
    }

    public boolean verify(String policyName, Rule rule, FlowExecutionLog log) {
        KieHelper kieHelper =  buildKieHelper(Sets.newHashSet(rule));
        Results results = kieHelper.verify();
        List<Message> messages = results.getMessages(Message.Level.ERROR);
        messages.forEach(message -> log.warn("Policy <" + policyName + "> rule generation error: " + message.getText()));
        return !results.hasMessages(Message.Level.ERROR);
    }

}
